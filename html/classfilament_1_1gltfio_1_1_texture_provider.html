<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Filament: TextureProvider Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Filament
   </div>
   <div id="projectbrief">A real time, physically-based renderer (PBR)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classfilament_1_1gltfio_1_1_texture_provider.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">TextureProvider Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html" title="TextureProvider is an interface that allows clients to implement their own texture decoding facility ...">TextureProvider</a> is an interface that allows clients to implement their own texture decoding facility for JPEG, PNG, or KTX2 content.  
 <a href="classfilament_1_1gltfio_1_1_texture_provider.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_texture_provider_8h_source.html">TextureProvider.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a006c94d8799205b8105ab715b2c2a769"><td class="memItemLeft" align="right" valign="top"><a id="a006c94d8799205b8105ab715b2c2a769"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>TextureFlags</b> : uint64_t { <b>NONE</b> = 0
, <b>sRGB</b> = 1 &lt;&lt; 0
 }</td></tr>
<tr class="separator:a006c94d8799205b8105ab715b2c2a769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07aa4e0e5011568bddbeda5a13a9390"><td class="memItemLeft" align="right" valign="top"><a id="ab07aa4e0e5011568bddbeda5a13a9390"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Texture</b> = <a class="el" href="classfilament_1_1_texture.html">filament::Texture</a></td></tr>
<tr class="separator:ab07aa4e0e5011568bddbeda5a13a9390"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5cdfa9675e9cd8c84d86a76de3e12c7d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classfilament_1_1_texture.html">Texture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a5cdfa9675e9cd8c84d86a76de3e12c7d">pushTexture</a> (const uint8_t *data, size_t byteCount, const char *mimeType, TextureFlags flags)=0</td></tr>
<tr class="memdesc:a5cdfa9675e9cd8c84d86a76de3e12c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Filament texture and pushes it to the asynchronous decoding queue.  <a href="classfilament_1_1gltfio_1_1_texture_provider.html#a5cdfa9675e9cd8c84d86a76de3e12c7d">More...</a><br /></td></tr>
<tr class="separator:a5cdfa9675e9cd8c84d86a76de3e12c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a433a3f8990e36554ba8651aa74a474"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classfilament_1_1_texture.html">Texture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a6a433a3f8990e36554ba8651aa74a474">popTexture</a> ()=0</td></tr>
<tr class="memdesc:a6a433a3f8990e36554ba8651aa74a474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any texture is ready to be removed from the asynchronous decoding queue, and if so pops it off.  <a href="classfilament_1_1gltfio_1_1_texture_provider.html#a6a433a3f8990e36554ba8651aa74a474">More...</a><br /></td></tr>
<tr class="separator:a6a433a3f8990e36554ba8651aa74a474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582ac10c086b7f4a5583d66d54f98b8b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a582ac10c086b7f4a5583d66d54f98b8b">updateQueue</a> ()=0</td></tr>
<tr class="memdesc:a582ac10c086b7f4a5583d66d54f98b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls textures in the queue and uploads mipmap images if any have emerged from the decoder.  <a href="classfilament_1_1gltfio_1_1_texture_provider.html#a582ac10c086b7f4a5583d66d54f98b8b">More...</a><br /></td></tr>
<tr class="separator:a582ac10c086b7f4a5583d66d54f98b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd891b8a5f97ec0f63195b4dae6633f"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#affd891b8a5f97ec0f63195b4dae6633f">getPushMessage</a> () const =0</td></tr>
<tr class="memdesc:affd891b8a5f97ec0f63195b4dae6633f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a failure message for the most recent call to <a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a5cdfa9675e9cd8c84d86a76de3e12c7d" title="Creates a Filament texture and pushes it to the asynchronous decoding queue.">pushTexture()</a>, or null for success.  <a href="classfilament_1_1gltfio_1_1_texture_provider.html#affd891b8a5f97ec0f63195b4dae6633f">More...</a><br /></td></tr>
<tr class="separator:affd891b8a5f97ec0f63195b4dae6633f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc3da2de4a850cf6f1bfa2e966504a9"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a7fc3da2de4a850cf6f1bfa2e966504a9">getPopMessage</a> () const =0</td></tr>
<tr class="memdesc:a7fc3da2de4a850cf6f1bfa2e966504a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a failure message for the most recent call to <a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a6a433a3f8990e36554ba8651aa74a474" title="Checks if any texture is ready to be removed from the asynchronous decoding queue,...">popTexture()</a>, or null for success.  <a href="classfilament_1_1gltfio_1_1_texture_provider.html#a7fc3da2de4a850cf6f1bfa2e966504a9">More...</a><br /></td></tr>
<tr class="separator:a7fc3da2de4a850cf6f1bfa2e966504a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f77c7ee8dfaac2801b1f9a09ff8fce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a73f77c7ee8dfaac2801b1f9a09ff8fce">waitForCompletion</a> ()=0</td></tr>
<tr class="memdesc:a73f77c7ee8dfaac2801b1f9a09ff8fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all outstanding decoding jobs to complete.  <a href="classfilament_1_1gltfio_1_1_texture_provider.html#a73f77c7ee8dfaac2801b1f9a09ff8fce">More...</a><br /></td></tr>
<tr class="separator:a73f77c7ee8dfaac2801b1f9a09ff8fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6584604ad32696283c725dab6ede7aa7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a6584604ad32696283c725dab6ede7aa7">cancelDecoding</a> ()=0</td></tr>
<tr class="memdesc:a6584604ad32696283c725dab6ede7aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels all not-yet-started decoding jobs and waits for all other jobs to complete.  <a href="classfilament_1_1gltfio_1_1_texture_provider.html#a6584604ad32696283c725dab6ede7aa7">More...</a><br /></td></tr>
<tr class="separator:a6584604ad32696283c725dab6ede7aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cbd0b6406e1c24aeb0fecf00d737b2"><td class="memItemLeft" align="right" valign="top"><a id="ae9cbd0b6406e1c24aeb0fecf00d737b2"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#ae9cbd0b6406e1c24aeb0fecf00d737b2">getPushedCount</a> () const =0</td></tr>
<tr class="memdesc:ae9cbd0b6406e1c24aeb0fecf00d737b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of successful push calls since the provider was created. <br /></td></tr>
<tr class="separator:ae9cbd0b6406e1c24aeb0fecf00d737b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed53a88277863b0f6c34f2b68a50214"><td class="memItemLeft" align="right" valign="top"><a id="a6ed53a88277863b0f6c34f2b68a50214"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a6ed53a88277863b0f6c34f2b68a50214">getPoppedCount</a> () const =0</td></tr>
<tr class="memdesc:a6ed53a88277863b0f6c34f2b68a50214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of successful pop calls since the provider was created. <br /></td></tr>
<tr class="separator:a6ed53a88277863b0f6c34f2b68a50214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88c26eec1fcf8f0aec2a96fd54b87a1"><td class="memItemLeft" align="right" valign="top"><a id="aa88c26eec1fcf8f0aec2a96fd54b87a1"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#aa88c26eec1fcf8f0aec2a96fd54b87a1">getDecodedCount</a> () const =0</td></tr>
<tr class="memdesc:aa88c26eec1fcf8f0aec2a96fd54b87a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of textures that have become ready-to-pop since the provider was created. <br /></td></tr>
<tr class="separator:aa88c26eec1fcf8f0aec2a96fd54b87a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html" title="TextureProvider is an interface that allows clients to implement their own texture decoding facility ...">TextureProvider</a> is an interface that allows clients to implement their own texture decoding facility for JPEG, PNG, or KTX2 content. </p>
<p>It constructs Filament <a class="el" href="classfilament_1_1_texture.html" title="Texture.">Texture</a> objects synchronously, but populates their miplevels asynchronously.</p>
<p>gltfio calls all public methods from the foreground thread, i.e. the thread that the Filament engine was created with. However the implementation may create 0 or more background threads to perform decoding work.</p>
<p>The following pseudocode illustrates how this interface could be used, but in practice the only client is the gltfio <a class="el" href="classfilament_1_1gltfio_1_1_resource_loader.html" title="Prepares and uploads vertex buffers and textures to the GPU.">ResourceLoader</a>. </p><pre class="fragment">filament::Engine* engine = ...;
TextureProvider* provider = createStbProvider(engine);

for (auto filename : textureFiles) {
    std::vector&lt;uint8_t&gt; buf = readEntireFile(filename);
    Texture* texture = provider-&gt;pushTexture(buf.data(), buf.size(), "image/png", 0);
    if (texture == nullptr) { puts(provider-&gt;getPushMessage()); exit(1); }
}

// At this point, the returned textures can be bound to material instances, but none of their
// miplevel images have been populated yet.

while (provider-&gt;getPoppedCount() &lt; provider-&gt;getPushedCount()) {
    sleep(200);

    // The following call gives the provider an opportunity to reap the results of any
    // background decoder work that has been completed (e.g. by calling Texture::setImage).
    provider-&gt;updateQueue();

    // Check for textures that now have all their miplevels initialized.
    while (Texture* texture = provider-&gt;popTexture()) {
        printf("%p has all its miplevels ready.\n", texture);
    }
}

delete provider;
</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6584604ad32696283c725dab6ede7aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6584604ad32696283c725dab6ede7aa7">&#9670;&nbsp;</a></span>cancelDecoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cancelDecoding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancels all not-yet-started decoding jobs and waits for all other jobs to complete. </p>
<p>Jobs that have already started cannot be canceled. Textures whose decoding process has been cancelled will be made poppable on the subsequent call to <a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a582ac10c086b7f4a5583d66d54f98b8b" title="Polls textures in the queue and uploads mipmap images if any have emerged from the decoder.">updateQueue()</a>. </p>

</div>
</div>
<a id="a7fc3da2de4a850cf6f1bfa2e966504a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc3da2de4a850cf6f1bfa2e966504a9">&#9670;&nbsp;</a></span>getPopMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* getPopMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a failure message for the most recent call to <a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a6a433a3f8990e36554ba8651aa74a474" title="Checks if any texture is ready to be removed from the asynchronous decoding queue,...">popTexture()</a>, or null for success. </p>
<p>If the most recent call to <a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a6a433a3f8990e36554ba8651aa74a474" title="Checks if any texture is ready to be removed from the asynchronous decoding queue,...">popTexture()</a> returned null, then no error occurred and this returns null. If the most recent call to <a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a6a433a3f8990e36554ba8651aa74a474" title="Checks if any texture is ready to be removed from the asynchronous decoding queue,...">popTexture()</a> returned a "complete" texture (i.e. all miplevels present), then this returns null. This returns non-null only if an error or cancellation occurred while decoding the popped texture.</p>
<p>The returned string is owned by the provider and becomes invalid after the next call to <a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a6a433a3f8990e36554ba8651aa74a474" title="Checks if any texture is ready to be removed from the asynchronous decoding queue,...">popTexture()</a>. </p>

</div>
</div>
<a id="affd891b8a5f97ec0f63195b4dae6633f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd891b8a5f97ec0f63195b4dae6633f">&#9670;&nbsp;</a></span>getPushMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* getPushMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a failure message for the most recent call to <a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a5cdfa9675e9cd8c84d86a76de3e12c7d" title="Creates a Filament texture and pushes it to the asynchronous decoding queue.">pushTexture()</a>, or null for success. </p>
<p>Note that this method does not pertain to the decoding process. If decoding fails, clients to can pop the incomplete texture off the queue and obtain a failure message using the getPopFailure() method.</p>
<p>The returned string is owned by the provider and becomes invalid after the next call to <a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a5cdfa9675e9cd8c84d86a76de3e12c7d" title="Creates a Filament texture and pushes it to the asynchronous decoding queue.">pushTexture()</a>. </p>

</div>
</div>
<a id="a6a433a3f8990e36554ba8651aa74a474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a433a3f8990e36554ba8651aa74a474">&#9670;&nbsp;</a></span>popTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classfilament_1_1_texture.html">Texture</a>* popTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if any texture is ready to be removed from the asynchronous decoding queue, and if so pops it off. </p>
<p>Unless an error or cancellation occurred during the decoding process, the returned texture should have all its miplevels populated. If the texture is not complete, the reason can be obtained with <a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a7fc3da2de4a850cf6f1bfa2e966504a9" title="Returns a failure message for the most recent call to popTexture(), or null for success.">getPopMessage()</a>.</p>
<p>Due to concurrency, textures are not necessarily popped off in the same order they were pushed. Returns null if there are no textures that are ready to be popped. </p>

</div>
</div>
<a id="a5cdfa9675e9cd8c84d86a76de3e12c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdfa9675e9cd8c84d86a76de3e12c7d">&#9670;&nbsp;</a></span>pushTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classfilament_1_1_texture.html">Texture</a>* pushTexture </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mimeType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TextureFlags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Filament texture and pushes it to the asynchronous decoding queue. </p>
<p>The provider synchronously determines the texture dimensions in order to create a Filament texture object, then populates the miplevels asynchronously.</p>
<p>If construction fails, nothing is pushed to the queue and null is returned. The failure reason can be obtained with <a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#affd891b8a5f97ec0f63195b4dae6633f" title="Returns a failure message for the most recent call to pushTexture(), or null for success.">getPushMessage()</a>. The given buffer pointer is not held, so the caller can free it immediately. It is also the caller's responsibility to free the returned <a class="el" href="classfilament_1_1_texture.html" title="Texture.">Texture</a> object, but it is only safe to do so after it has been popped from the queue. </p>

</div>
</div>
<a id="a582ac10c086b7f4a5583d66d54f98b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582ac10c086b7f4a5583d66d54f98b8b">&#9670;&nbsp;</a></span>updateQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void updateQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polls textures in the queue and uploads mipmap images if any have emerged from the decoder. </p>
<p>This gives the provider an opportunity to call <a class="el" href="classfilament_1_1_texture.html#ad074e01381e6b573a1614c19caa34006" title="Updates a sub-image of a 3D texture or 2D texture array for a level.">Texture::setImage()</a> on the foreground thread. If needed, it can also call <a class="el" href="classfilament_1_1_texture.html#a1d4155c5aab4cd249ed53761652ef8b7" title="Generates all the mipmap levels automatically.">Texture::generateMipmaps()</a> here.</p>
<p>Items in the decoding queue can become "poppable" only during this call. </p>

</div>
</div>
<a id="a73f77c7ee8dfaac2801b1f9a09ff8fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f77c7ee8dfaac2801b1f9a09ff8fce">&#9670;&nbsp;</a></span>waitForCompletion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void waitForCompletion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for all outstanding decoding jobs to complete. </p>
<p>Clients should call <a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html#a582ac10c086b7f4a5583d66d54f98b8b" title="Polls textures in the queue and uploads mipmap images if any have emerged from the decoder.">updateQueue()</a> afterwards if they wish to update the push / pop queue. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/mnt/c/Users/Brett/Downloads/filament-main/libs/gltfio/include/gltfio/<a class="el" href="_texture_provider_8h_source.html">TextureProvider.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>filament</b></li><li class="navelem"><a class="el" href="namespacefilament_1_1gltfio.html">gltfio</a></li><li class="navelem"><a class="el" href="classfilament_1_1gltfio_1_1_texture_provider.html">TextureProvider</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
